@file:Suppress("KDocUnresolvedReference")

package com.jacktor.rootchecker

import android.content.Context
import android.content.pm.PackageManager
import android.os.Build
import com.jacktor.rootchecker.util.QLog
import java.io.BufferedReader
import java.io.File
import java.io.IOException
import java.io.InputStreamReader
import java.util.Scanner

/**
 * A simple root checker that gives an *indication* if the device is rooted or not.
 * Disclaimer: **root==god**, so there's no 100% way to check for root.
 */
@Suppress("unused")
class RootChecker(private val mContext: Context) {
    private var loggingEnabled = true
    val isRooted: Boolean
        /**
         * Run all the root detection checks.
         *
         * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
         */
        get() = (detectRootManagementApps() || detectPotentiallyDangerousApps() || checkForBinary(
            Const.BINARY_SU
        )
                || checkForDangerousProps() || checkForRWPaths()
                || detectTestKeys() || checkSuExists() || checkForRootNative() || checkForMagiskBinary())

    @get:Deprecated(
        """This method is deprecated as checking without the busybox binary is now the
      default. This is because many manufacturers leave this binary on production devices.""",
        ReplaceWith("this.isRooted")
    )
    val isRootedWithoutBusyBoxCheck: Boolean
        get() = this.isRooted
    val isRootedWithBusyBoxCheck: Boolean
        /**
         * Run all the checks including checking for the busybox binary.
         * Warning: Busybox binary is not always an indication of root, many manufacturers leave this
         * binary on production devices
         * @return true, we think there's a good *indication* of root | false good *indication* of no root (could still be cloaked)
         */
        get() = (detectRootManagementApps() || detectPotentiallyDangerousApps() || checkForBinary(
            Const.BINARY_SU
        )
                || checkForBinary(Const.BINARY_BUSYBOX) || checkForDangerousProps() || checkForRWPaths()
                || detectTestKeys() || checkSuExists() || checkForRootNative() || checkForMagiskBinary())

    /**
     * Release-Keys and Test-Keys has to do with how the kernel is signed when it is compiled.
     * Test-Keys means it was signed with a custom key generated by a third-party developer.
     * @return true if signed with Test-keys
     */
    private fun detectTestKeys(): Boolean {
        val buildTags = Build.TAGS
        return buildTags != null && buildTags.contains("test-keys")
    }
    /**
     * Using the PackageManager, check for a list of well known root apps. @link {Const.knownRootAppsPackages}
     * @param additionalRootManagementApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    /**
     * Using the PackageManager, check for a list of well known root apps. @link {Const.knownRootAppsPackages}
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    fun detectRootManagementApps(additionalRootManagementApps: Array<String?>? = null): Boolean {

        // Create a list of package names to iterate over from constants any others provided
        val packages = ArrayList(listOf(*Const.knownRootAppsPackages))
        if (!additionalRootManagementApps.isNullOrEmpty()) {
            packages.addAll(listOf(*additionalRootManagementApps))
        }
        return isAnyPackageFromListInstalled(packages)
    }
    /**
     * Using the PackageManager, check for a list of well known apps that require root. @link {Const.knownRootAppsPackages}
     * @param additionalDangerousApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    /**
     * Using the PackageManager, check for a list of well known apps that require root. @link {Const.knownRootAppsPackages}
     * @return true if one of the apps it's installed
     */
    @JvmOverloads
    fun detectPotentiallyDangerousApps(additionalDangerousApps: Array<String?>? = null): Boolean {

        // Create a list of package names to iterate over from constants any others provided
        val packages = ArrayList<String?>()
        packages.addAll(listOf(*Const.knownDangerousAppsPackages))
        if (!additionalDangerousApps.isNullOrEmpty()) {
            packages.addAll(ArrayList(listOf(*additionalDangerousApps)))
        }
        return isAnyPackageFromListInstalled(packages)
    }

    /**
     * Using the PackageManager, check for a list of well known root cloak apps. @link {Const.knownRootAppsPackages}
     * and checks for native library read access
     * @return true if one of the apps it's installed
     */
    fun detectRootCloakingApps(): Boolean {
        return detectRootCloakingApps(null) || canLoadNativeLibrary() && !checkForNativeLibraryReadAccess()
    }

    /**
     * Using the PackageManager, check for a list of well known root cloak apps. @link {Const.knownRootAppsPackages}
     * @param additionalRootCloakingApps - array of additional packagenames to search for
     * @return true if one of the apps it's installed
     */
    @Suppress("SameParameterValue")
    private fun detectRootCloakingApps(additionalRootCloakingApps: Array<String?>?): Boolean {

        // Create a list of package names to iterate over from constants any others provided
        val packages = ArrayList(listOf(*Const.knownRootCloakingPackages))
        if (!additionalRootCloakingApps.isNullOrEmpty()) {
            packages.addAll(listOf(*additionalRootCloakingApps))
        }
        return isAnyPackageFromListInstalled(packages)
    }

    /**
     * Checks various (Const.suPaths) common locations for the SU binary
     * @return true if found
     */
    fun checkForSuBinary(): Boolean {
        return checkForBinary(Const.BINARY_SU)
    }

    /**
     * Checks various (Const.suPaths) common locations for the magisk binary (a well know root level program)
     * @return true if found
     */
    private fun checkForMagiskBinary(): Boolean {
        return checkForBinary("magisk")
    }

    /**
     * Checks various (Const.suPaths) common locations for the busybox binary (a well know root level program)
     * @return true if found
     */
    fun checkForBusyBoxBinary(): Boolean {
        return checkForBinary(Const.BINARY_BUSYBOX)
    }

    /**
     *
     * @param filename - check for this existence of this file
     * @return true if found
     */
    private fun checkForBinary(filename: String): Boolean {
        val pathsArray = Const.paths
        var result = false
        for (path in pathsArray) {
            val completePath = path + filename
            val f = File(path, filename)
            val fileExists = f.exists()
            if (fileExists) {
                QLog.v("$completePath binary detected!")
                result = true
            }
        }
        return result
    }

    /**
     *
     * @param logging - set to true for logging
     */
    fun setLogging(logging: Boolean) {
        loggingEnabled = logging
        QLog.LOGGING_LEVEL = if (logging) QLog.ALL else QLog.NONE
    }

    private fun propsReader(): Array<String>? {
        return try {
            val inputstream = Runtime.getRuntime().exec("getprop").inputStream ?: return null
            val propVal = Scanner(inputstream).useDelimiter("\\A").next()
            propVal.split("\n".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
        } catch (e: IOException) {
            QLog.e(e)
            null
        } catch (e: NoSuchElementException) {
            QLog.e(e)
            null
        }
    }

    private fun mountReader(): Array<String>? {
        return try {
            val inputstream = Runtime.getRuntime().exec("mount").inputStream ?: return null
            val propVal = Scanner(inputstream).useDelimiter("\\A").next()
            propVal.split("\n".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
        } catch (e: IOException) {
            QLog.e(e)
            null
        } catch (e: NoSuchElementException) {
            QLog.e(e)
            null
        }
    }

    /**
     * Check if any package in the list is installed
     * @param packages - list of packages to search for
     * @return true if any of the packages are installed
     */
    private fun isAnyPackageFromListInstalled(packages: ArrayList<String?>): Boolean {
        var result = false
        val pm = mContext.packageManager
        for (packageName in packages) {
            try {
                // Root app detected
                pm.getPackageInfo(packageName!!, 0)
                QLog.e("$packageName ROOT management app detected!")
                result = true
            } catch (e: PackageManager.NameNotFoundException) {
                // Exception thrown, package is not installed into the system
            }
        }
        return result
    }

    /**
     * Checks for several system properties for
     * @return - true if dangerous props are found
     */
    private fun checkForDangerousProps(): Boolean {
        val dangerousProps: MutableMap<String, String> = HashMap()
        dangerousProps["ro.debuggable"] = "1"
        dangerousProps["ro.secure"] = "0"
        var result = false
        val lines = propsReader()
            ?: // Could not read, assume false;
            return false
        for (line in lines) {
            for (key in dangerousProps.keys) {
                if (line.contains(key)) {
                    var badValue = dangerousProps[key]
                    badValue = "[$badValue]"
                    if (line.contains(badValue)) {
                        QLog.v("$key = $badValue detected!")
                        result = true
                    }
                }
            }
        }
        return result
    }

    /**
     * When you're root you can change the permissions on common system directories, this method checks if any of these patha Const.pathsThatShouldNotBeWritable are writable.
     * @return true if one of the dir is writable
     */
    private fun checkForRWPaths(): Boolean {
        var result = false

        //Run the command "mount" to retrieve all mounted directories
        val lines = mountReader()
            ?: // Could not read, assume false;
            return false

        //The SDK version of the software currently running on this hardware device.
        val sdkVersion = Build.VERSION.SDK_INT
        /**
         *
         * In devices that are running Android 6 and less, the mount command line has an output as follow:
         *
         * <fs_spec_path> <fs_file> <fs_spec> <fs_mntopts>
         *
         * where :
         * - fs_spec_path: describes the path of the device or remote filesystem to be mounted.
         * - fs_file: describes the mount point for the filesystem.
         * - fs_spec describes the block device or remote filesystem to be mounted.
         * - fs_mntopts: describes the mount options associated with the filesystem. (E.g. "rw,nosuid,nodev" )
         *
        </fs_mntopts></fs_spec></fs_file></fs_spec_path> */
        /** In devices running Android which is greater than Marshmallow, the mount command output is as follow:
         *
         * <fs_spec> <ON> <fs_file> <TYPE> <fs_vfs_type> <(fs_mntopts)>
         *
         * where :
         * - fs_spec describes the block device or remote filesystem to be mounted.
         * - fs_file: describes the mount point for the filesystem.
         * - fs_vfs_type: describes the type of the filesystem.
         * - fs_mntopts: describes the mount options associated with the filesystem. (E.g. "(rw,seclabel,nosuid,nodev,relatime)" )
        </fs_vfs_type></TYPE></fs_file></ON></fs_spec> */
        for (line in lines) {

            // Split lines into parts
            val args = line.split(" ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            if (sdkVersion <= Build.VERSION_CODES.M && args.size < 4 || sdkVersion > Build.VERSION_CODES.M && args.size < 6) {
                // If we don't have enough options per line, skip this and log an error
                QLog.e("Error formatting mount line: $line")
                continue
            }
            var mountPoint: String
            var mountOptions: String
            /**
             * To check if the device is running Android version higher than Marshmallow or not
             */
            if (sdkVersion > Build.VERSION_CODES.M) {
                mountPoint = args[2]
                mountOptions = args[5]
            } else {
                mountPoint = args[1]
                mountOptions = args[3]
            }
            for (pathToCheck in Const.pathsThatShouldNotBeWritable) {
                if (mountPoint.equals(pathToCheck, ignoreCase = true)) {
                    /**
                     * If the device is running an Android version above Marshmallow,
                     * need to remove parentheses from options parameter;
                     */
                    if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M) {
                        mountOptions = mountOptions.replace("(", "")
                        mountOptions = mountOptions.replace(")", "")
                    }

                    // Split options out and compare against "rw" to avoid false positives
                    for (option in mountOptions.split(",".toRegex()).dropLastWhile { it.isEmpty() }
                        .toTypedArray()) {
                        if (option.equals("rw", ignoreCase = true)) {
                            QLog.v("$pathToCheck path is mounted with rw permissions! $line")
                            result = true
                            break
                        }
                    }
                }
            }
        }
        return result
    }

    /**
     * A variation on the checking for SU, this attempts a 'which su'
     * @return true if su found
     */
    private fun checkSuExists(): Boolean {
        var process: Process? = null
        return try {
            process = Runtime.getRuntime().exec(arrayOf("which", Const.BINARY_SU))
            val `in` = BufferedReader(InputStreamReader(process.inputStream))
            `in`.readLine() != null
        } catch (t: Throwable) {
            false
        } finally {
            process?.destroy()
        }
    }

    /**
     * Checks if device has ReadAccess to the Native Library
     * Precondition: canLoadNativeLibrary() ran before this and returned true
     *
     * Description: RootCloak automatically blocks read access to the Native Libraries, however
     * allows for them to be loaded into memory. This check is an indication that RootCloak is
     * installed onto the device.
     *
     * @return true if device has Read Access | false if UnsatisfiedLinkError Occurs
     */
    private fun checkForNativeLibraryReadAccess(): Boolean {
        val rootCheckerNative = RootCheckerNative()
        return try {
            rootCheckerNative.setLogDebugMessages(loggingEnabled)
            true
        } catch (e: UnsatisfiedLinkError) {
            false
        }
    }

    /**
     * Checks if it is possible to load our native library
     * @return true if we can | false if not
     */
    private fun canLoadNativeLibrary(): Boolean {
        return RootCheckerNative().wasNativeLibraryLoaded()
    }

    /**
     * Native checks are often harder to cloak/trick so here we call through to our native root checker
     * @return true if we found su | false if not, or the native library could not be loaded / accessed
     */
    private fun checkForRootNative(): Boolean {
        if (!canLoadNativeLibrary()) {
            QLog.e("We could not load the native library to test for root")
            return false
        }
        val paths = Const.paths
        val checkPaths = arrayOfNulls<String>(paths.size)
        for (i in checkPaths.indices) {
            checkPaths[i] = paths[i] + Const.BINARY_SU
        }
        val rootCheckerNative = RootCheckerNative()
        return try {
            rootCheckerNative.setLogDebugMessages(loggingEnabled)
            rootCheckerNative.checkForRoot(checkPaths) > 0
        } catch (e: UnsatisfiedLinkError) {
            false
        }
    }
}